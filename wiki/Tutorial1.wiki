# A tutorial on how to profile a simple program with aprof and analyze the profiling data using aprof-plot

= Profiling a simple program =

This tutorial explains how to profile a program with aprof and how to analyze the collected profiling data using aprof-plot.

== A simple program ==

Suppose we want to analyze the performance of our implementation of a [http://en.wikipedia.org/wiki/Quicksort quick sort algorithm]. For example, this can be our program code:

{{{
#include <stdlib.h>
#include <time.h>
#include <stdio.h>

int partition(int v[], int a, int b) {
	int pivot = a;
	for (;;) {
		while (a < b && v[a] <= v[pivot]) a++;
		while (v[b] > v[pivot]) b--;
		if (a >= b) break;
		int temp = v[a];
		v[a] = v[b];
		v[b] = temp;
	}
	if (v[b] != v[pivot]) {
		int temp = v[b];	
		v[b] = v[pivot];
		v[pivot] = temp;
	}
	return b;
}

void quick_sort_ric(int v[], int a, int b) {
	int m;
	if (a >= b) return;
	m = partition(v, a, b);
	quick_sort_ric(v, a, m-1);
	quick_sort_ric(v, m+1, b);
}

int main() {
    
	int v[1024*10];
	srand(time(0));
	int n = sizeof(v)/sizeof(int);
	int j = n, i = 0;

	for (j = 0; j < n; j += 100) {
	
		for (i = 0; i < j; i++)
			v[i] = rand() % (j+1);

		quick_sort_ric(v, 0, j-1);
	}
	
	printf("End\n");

	return 0;
}
}}} 

The `main()` function invokes our quick sort implementation different times. Each time the array is filled with some random numbers. In a real program probably our quick sort implementation would be called during the normal execution of our application and so we don't need to create an _unrealistic_ `main()` in order to profile our code. `quick_sort_ric()` and `partition()` are textbook implementations and therefore they are not very optimized (the first element of the array is chosen as pivot by `partition()`).

We expect that:
  * `partition()` should be O(n)
  * `quick_sort_ric()` should be O( n `*` log(n) ) because the input is composed by random integers (average case performance). 

== Compiling the program ==

In order to profile our code we don't need any special compilation flag (e.g, `-g` or `-pg`). The only requirement is that our application binary should not be stripped out of the function symbols (by default GCC does not strip a binary). So, we can compile our example code in the usual way:
{{{
gcc -o quick_tutorial quick_tutorial.c
}}}
where `quick_tutorial.c` is a text file containing the previous example code.

== Profiling ==

You can install `aprof` by following the _[#Install_aprof Instructions for installing aprof]_. We can profile our program with the following command:
{{{
path-to-aprof/inst/bin/valgrind --tool=aprof ./quick_tutorial
}}}
The output should be somithing like this:
{{{
==28001== aprof-0.1.1, Input-sensitive Profiler - http://code.google.com/p/aprof/
==28001== by Emilio Coppa, Camil Demetrescu, Irene Finocchi
==28001== Using Valgrind-3.9.0.SVN and LibVEX; rerun with -h for copyright info
==28001== Command: ./quick_tutorial
==28001== 
End
==28001==
}}}
The first and last line of the output provide us the PID (`28001`) of the program execution. In the current working directory we should find a report called `28001_0_4.aprof` (or `quick_tutorial_0_4.aprof`). This report is a text-file written following the [ReportFileFormat aprof report file format].

== Analyzing the profiling data ==

In order to analyze our report we can use [aprof_plot_manual aprof-plot], a Java tool for visualizing reports generated by `aprof`. You can install `aprof-plot` by following the _[Install#Install_aprof-plot Instructions for installing aprof-plot]_. You can run it by following the [BasicUsage#Visualize_profile_reports basic usage guide].

Open the report in `aprof-plot` using the menu `File > Open File...` and search the report in your filesystem. This is what you should see:

[http://aprof.googlecode.com/svn/trunk/wiki_images/tutorial-1.png] 