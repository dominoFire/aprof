# A tutorial on how to profile a simple program with aprof and analyze the profiling data using aprof-plot

= Profiling a simple program =

This tutorial explains how to profile a program with aprof and how to analyze the collected profiling data using aprof-plot.

== A simple program ==

Suppose we want to analyze the performance of our implementation of a [http://en.wikipedia.org/wiki/Quicksort quick sort algorithm]. For example, this can be our program code:

{{{
#include <stdlib.h>
#include <time.h>

int partition(int v[], int a, int b) {
	int pivot = a;
	for (;;) {
		while (a < b && v[a] <= v[pivot]) a++;
		while (v[b] > v[pivot]) b--;
		if (a >= b) break;
		int temp = v[a];
		v[a] = v[b];
		v[b] = temp;
	}
	if (v[b] != v[pivot]) {
		int temp = v[b];	
		v[b] = v[pivot];
		v[pivot] = temp;
	}
	return b;
}

void quick_sort_ric(int v[], int a, int b) {
	int m;
	if (a >= b) return;
	m = partition(v, a, b);
	quick_sort_ric(v, a, m-1);
	quick_sort_ric(v, m+1, b);
}

int main() {
    
	int v[1024*10];
	srand(time(0));
	int n = sizeof(v)/sizeof(int);
	int j = n, i = 0;

	for (j = 0; j < n; j += 100) {
	
		for (i = 0; i < j; i++)
			v[i] = rand() % (j+1);

		quick_sort_ric(v, 0, j-1);
	}
    
	return 0;
}
}}} 

The `main()` function invokes our quick sort implementation different times. Each time the array is filled with some random numbers. In a real program probably our quick sort implementation would be called during the normal execution of our application and so we don't need to create an _unrealistic_ `main` in order to profile our code.

The quick sort implementation is not very optimized but we expect:
  * `partition()` should be O(n)
  * `quick_sort_ric()` should be O( n `*` log(n) ) because the input is composed by random integers (average case performance). 