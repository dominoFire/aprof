# aprof user manual

= aprof: an input-sensitive perfomance profiler =


aprof is a [http://valgrind.org/ Valgrind] tool. You can find a more [http://valgrind.org/docs/manual/manual.html general user manual] about this binary instrumentation framework on its official site.

== Overview ==

Input-Sensitive profiling is a novel performance profiling methodology for helping developers discover hidden asymptotic inefficiencies in the code. It has been described in a [http://code.google.com/p/aprof/#Research_papers PLDI 2012 paper], where you can find a more detailed description about this technique.

From one or more runs of a program, `aprof` automatically measures how the performance of individual routines scales as a function of the input size, yielding clues to their growth rate. The output of the profiler is, for each executed routine of the program, a set of tuples that aggregate performance costs by input size. A distinguishing feature of this approach is the ability to automatically measure the size of the input given to a generic routine. In classical analysis of algorithms based on theoretical cost models, the input size of a procedure is a parameter known a _priori_ and clear from the abstract description of the underlying algorithm. But in practice, when a routine is invoked in the context of a real application, the size of its input is unknown to the analysis tool. 

=== Input size estimation: Read Memory Size (RMS) ===

In order to estimate the input size of a routine invocation at runtime, `aprof` uses a new effective metric called *Read Memory Size* (*RMS*): 

  The read memory size (RMS) of the execution of a routine `f` is the number of distinct memory cells first accessed by `f`, or by a descendant of `f` in the call tree, with a read operation.

The main idea behind the definition of RMS is that cells that are accessed by a function for the first time with a read operation contain the input values of the routine. Conversely, if a cell is first written and then read by the routine, the read value is not part of the input as it was determined by the routine itself.

To better understand this metric, let's discuss some examples.

==== Example 1 ====

{{{
void swap(int * a, int * b) {
    int temp = *a; 
    *a = *b; 
    *b = temp; 
}
}}}

This function takes as arguments two pointers to integers and simply swaps their values by using a temporary variable. Any call of `swap` has RMS equal to 4, which accounts for the addresses of lvalues a, b, `*`a and `*`b. Notice that each of them is first accessed by a read operation: a and `*`a at line 2, b and `*`b at line 3. Variable temp is not counted in the RMS as it is first accessed by the write operation at line 2.

In the next example we will understand why an estimation of the input size can be really useful.

==== Example 2 ====

{{{
int count_zero(int v[], int n) {
    int i, count = 0;
    for (i=0; i<n; i++) count += (v[i]==0 ? 1:0);
    return count;
}
}}}

The function, which counts the number of 0’s in the input array v, has RMS `n + 2`: it reads variables `v` and `n`, and the first `n` cells of the array pointed to by `v`. `aprof` collect one performance tuple for
each distinct value of `n` on which count zero is called during the execution of the program.

Suppose that `count_zero` requires `n` seconds to be executed and your application calls `count_zero` three times. For example:

{{{
int sum = 0;
int v[1024];
sum += count_zero(v, 256); // count zeroes first 256 int of v[]
sum += count_zero(v, 512); // count zeroes first 512 int of v[]
sum += count_zero(v, 1024); // count zeroes first 1024 int of v[]
}}}
So, the first call requires 256 seconds, the second one 512 and the third one 1024 seconds. If we now profile our application with a traditional profiler and with `aprof` we get:

|| || *traditional profiler* || *`aprof`* || 
|| `count_zero` || calls: 3 <br> total exec time: 1792 secs <br> average exec time: 597.3 secs || calls: 3 <br> total exec time: 1792 secs <br> average exec time: 597.3 secs <br> execution`]`1`]`: input size 258, time 256 secs <br> execution`[`2`]`: input size 514, time 512 secs <br> execution`]`3`]`: input size 1026, time 1024 secs ||

The info provided by `aprof` is a lot more precise: for example you can easily draw a chart and evaluate the trend growth rate (a linear trend as expected). A traditional profiler can only give you aggregate info because it does not know the input size of a routine invocation and therefore it treats all the routine calls as executed on the same unknown input size.

|| *traditional profiler* || *`aprof`* ||
|| [http://aprof.googlecode.com/svn/trunk/wiki_images/example-2a.png] || [http://aprof.googlecode.com/svn/trunk/wiki_images/example-2b.png] ||

==== Example 3 ====

The RMS metric is really powerful. Suppose your `count_zero` code is:
{{{
int count_zero(int v[], int n) {
    if (n<1) return 0;
    return (v[n-1]==0 ? 1:0) + count_zero(v, n-1);
}
}}}
This is a recursive implementation of the previous iterative `count_zero`. Observe that, just like the iterative version, the first invocation of function `count_zero` has RMS `n`,,1,,` = n + 2`. However, calling `count_zero` on parameter `n` also results in `n` additional recursive activations of the function for all size values ranging from `n − 1` down to `0`. Therefore, `aprof` collect `n + 1` performance
tuples from just one starting activation. The read memory size corresponding to the i-th invocation is `n`,,i,, = `n − i + 3`, for each i ∈ [1, n + 1].

The result of recursion is that from just this code:
{{{
int sum = 0;
int v[1024];
sum += count_zero(v, 1024);
}}}
on this example `aprof` gives us all the information needed to draw a chart with 1024 points and perform an accurate evaluation of the tren growth rate for `count_zero`.

== Usage ==

See the [BasicUsage#Profile_a_program basic usage page]

== aprof command-line options ==

`--memory-resolution=<k> [default: 4]`

  To reduce the space needed by the shadow memory, `aprof` allows users to configure the resolution of distinct observable memory objects, trading space for accuracy. This can potentially impact the number of distinct RMS values observed by `aprof`, and therefore the number of collected performance tuples. We denote by k the size in bytes of the smallest observable objects, which we assume to be aligned to addresses multiple of k. For k = 1, we have the finest resolution, shadowing the addresses of all accessed individual memory bytes. For k = 2, we trace accesses to 2-bytes words aligned at 16-bit boundaries, halving the universe of timestamps. The larger k, the smaller the RMS accuracy for routines working on small objects (e.g., strings of characters) and the smaller the size of the shadow memory. 
  Possible valid values are: 1, 2, 4, 8, 16. 

`--merge-report-threads=yes|no [default: no]`

  Merge reports of all threads for the current process. This option is available only on GNU/Linux.

`--merge-report-runs=yes|no [default: no]`

  Merge reports of the current program with reports of previous program runs. Reports must be in the current working directory. This option implies `--merge-report-threads=yes` and it is available only on GNU/Linux.

== aprof specific client requests ==

In the stable version of `aprof`, client requests are used only for external function entry/exit point tracing. See [AprofOnARM_PPC this page] for more details. Two client requests are parsed by `aprof`:

  # `VALGRIND_DO_CLIENT_REQUEST(<dummy_var>, 0, VG_USERREQ_TOOL_BASE('V', 'A'), <function_identifier>, <function_status>, 0, 0, 0);`
  # `VALGRIND_DO_CLIENT_REQUEST(<dummy_var>, 0, VG_USERREQ_TOOL_BASE('V', 'A'), <function_identifier>, <function_status>, 0, 0, 0);`	

where:
  * `<dummy_var>` is an int variable (not used)
  * `<function_identifier>` is an identifier of the function (e.g., the routine address)
  * `<function_status>`: one if entry point; two if exit point

== Report file format ==

See the [ReportFileFormat report file format page].