# aprof user manual

= aprof: an input-sensitive perfomance profiler =


aprof is a [http://valgrind.org/ Valgrind] tool. You can find a more [http://valgrind.org/docs/manual/manual.html general user manual] about this binary instrumentation framework on its official site.

== Overview ==

Input-Sensitive profiling is a novel performance profiling methodology for helping developers discover hidden asymptotic inefficiencies in the code. It has been described in a [http://code.google.com/p/aprof/#Research_papers PLDI 2012 paper], where you can find a more detailed description about this technique.

From one or more runs of a program, `aprof` automatically measures how the performance of individual routines scales as a function of the input size, yielding clues to their growth rate. The output of the profiler is, for each executed routine of the program, a set of tuples that aggregate performance costs by input size. A distinguishing feature of this approach is the ability to automatically measure the size of the input given to a generic routine. In classical analysis of algorithms based on theoretical cost models, the input size of a procedure is a parameter known a _priori_ and clear from the abstract description of the underlying algorithm. But in practice, when a routine is invoked in the context of a real application, the size of its input is unknown to the analysis tool. 

=== Input size estimation: Read Memory Size (RMS) ===

In order to estimate the input size of a routine invocation at runtime, `aprof` uses a new effective metric called *Read Memory Size* (*RMS*) that counts the number of distinct memory cells first accessed by a routine `f`, or by a descendant of `f` in the call tree, with a read operation. The main idea behind the definition of RMS is that cells that are accessed by a function for the first time with a read operation contain the input values of the routine. Conversely, if a cell is first written and then read by the routine, the read value is not part of the input as it was determined by the routine itself.

To better understand this metric, let's discuss an example:

{{{
void swap(int * a, int * b) {
    int temp = *a; 
    *a = *b; 
    *b = temp; 
}
}}}

This function takes as arguments two pointers to integers and simply swaps their values by using a temporary variable. Any call of `swap` has RMS equal to 4, which accounts for the addresses of lvalues a, b, *a and *b. Notice that each of them is first accessed by a read operation: a and *a at line 2, b and *b at line 3. Variable temp is not counted in the RMS as it is first accessed by the write operation at line 2.

== Usage ==

See the [BasicUsage#Profile_a_program basic usage page]

== aprof command-line options ==

`--memory-resolution=<k> [default: 4]`

  To reduce the space needed by the shadow memory, `aprof` allows users to configure the resolution of distinct observable memory objects, trading space for accuracy. This can potentially impact the number of distinct RMS values observed by `aprof`, and therefore the number of collected performance tuples. We denote by k the size in bytes of the smallest observable objects, which we assume to be aligned to addresses multiple of k. For k = 1, we have the finest resolution, shadowing the addresses of all accessed individual memory bytes. For k = 2, we trace accesses to 2-bytes words aligned at 16-bit boundaries, halving the universe of timestamps. The larger k, the smaller the RMS accuracy for routines working on small objects (e.g., strings of characters) and the smaller the size of the shadow memory. 
  Possible valid values are: 1, 2, 4, 8, 16. 

`--merge-report-threads=yes|no [default: no]`

  Merge reports of all threads for the current process. This option is available only on GNU/Linux.

`--merge-report-runs=yes|no [default: no]`

  Merge reports of the current program with reports of previous program runs. Reports must be in the current working directory. This option implies `--merge-report-threads=yes` and it is available only on GNU/Linux.

== aprof specific client requests ==

In the stable version of `aprof`, client requests are used only for external function entry/exit point tracing. See [AprofOnARM_PPC this page] for more details. Two client requests are parsed by `aprof`:

  # `VALGRIND_DO_CLIENT_REQUEST(<dummy_var>, 0, VG_USERREQ_TOOL_BASE('V', 'A'), <function_identifier>, <function_status>, 0, 0, 0);`
  # `VALGRIND_DO_CLIENT_REQUEST(<dummy_var>, 0, VG_USERREQ_TOOL_BASE('V', 'A'), <function_identifier>, <function_status>, 0, 0, 0);`	

where:
  * `<dummy_var>` is an int variable (not used)
  * `<function_identifier>` is an identifier of the function (e.g., the routine address)
  * `<function_status>`: one if entry point; two if exit point

== Report file format ==

See the [ReportFileFormat report file format page].