/*
 * Report generator
 * 
 * Last changed: $Date: 2013-08-30 11:29:14 +0200 (ven, 30 ago 2013) $
 * Revision:     $Rev: 884 $
 */
 
 /*
   This file is part of aprof, an input sensitive profiler.

   Copyright (C) 2011-2013, Emilio Coppa (ercoppa@gmail.com),
                            Camil Demetrescu,
                            Irene Finocchi,
                            Romolo Marotta

   This program is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License as
   published by the Free Software Foundation; either version 2 of the
   License, or (at your option) any later version.

   This program is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307, USA.

   The GNU General Public License is contained in the file COPYING.
*/

#include "aprof.h"

static inline HChar * report_name(  HChar * name, 
                                    UInt tid, 
                                    UInt attempt, 
                                    const HChar * prog_name) {
    
    UInt offset = 0;
    #if REPORT_NAME == 1
    offset += VG_(sprintf)(name, "%s_", VG_(basename)(prog_name));
    #endif
    
    if (attempt > 0) attempt += 1024;
    VG_(sprintf)(name + offset, "%d_%u_%d.aprof", VG_(getpid)(), 
                    tid - 1 + attempt, APROF_(runtime).memory_resolution);
                    
    return name;
}

static inline ULong get_binary_mtime(const HChar * exec) {
    
    const HChar * exe_name = ML_(find_executable)(exec);
    struct vg_stat buf;
    VG_(stat)(exe_name, &buf);
    return buf.mtime;
}

static FILE * init_report(const HChar * prog_name, ThreadId tid, 
                                HChar ** filename_p) {
    
    HChar filename_priv[NAME_SIZE] = {0};
    HChar * filename = NULL;
    HChar * name = NULL;
    FILE * report = NULL;
    UInt attempt = 0;
    
    while (report == NULL && attempt < 1024) {
    
        name = report_name(filename_priv, tid, attempt, prog_name);
        if (APROF_(runtime).log_dir != NULL) {
            
            filename = VG_(calloc)("log", NAME_SIZE, 1);
            VG_(sprintf)(filename, "%s/%s", APROF_(runtime).log_dir, name);
            
        } else {
            
            filename = VG_(expand_file_name)("log", name);
        }
        
        report = APROF_(fopen)(filename);
        attempt++;
    }
    
    *filename_p = filename;
    return report;
}

void APROF_(generate_report)(ThreadData * tdata, ThreadId tid) {
    
    HChar * filename = NULL;
    HChar * prog_name = (HChar *) VG_(args_the_exename);
    FILE * report = init_report(prog_name, tid, &filename);

    APROF_(assert)(report != NULL, "Report can not be created: %s", filename);

    // check binary mtime
    if (APROF_(runtime).binary_mtime == 0)
        APROF_(runtime).binary_mtime = get_binary_mtime(prog_name);

    // write header
    APROF_(fprintf)(report, "c -------------------------------------\n");
    APROF_(fprintf)(report, "c report generated by aprof (valgrind) \n");
    APROF_(fprintf)(report, "c -------------------------------------\n");
    
    // write version 
    APROF_(fprintf)(report, "v %d\n", REPORT_VERSION);
    
    // Maximum value for the metric
    #if COST == RDTSC
    APROF_(fprintf)(report, "k %llu\n", APROF_(time)(tdata)
                                        - tdata->cost 
                                        - tdata->skip_cost;
                                        + tdata->extra_cost);
    #else 
    APROF_(fprintf)(report, "k %llu\n", APROF_(time)(tdata) 
                                        - tdata->skip_cost
                                        + tdata->extra_cost);
    #endif
    
    // write mtime binary
    APROF_(fprintf)(report, "e %llu\n", APROF_(runtime).binary_mtime);
    
    // write performance metric type
    #if COST == BB_COUNT
    APROF_(fprintf)(report, "m bb-count\n");
    #elif COST == RDTSC
    APROF_(fprintf)(report, "m time-usec\n");
    #elif COST == INSTR
    APROF_(fprintf)(report, "m vex-instr\n");
    #endif
    
    // write input metric type
    if (APROF_(runtime).input_metric == RMS)
        APROF_(fprintf)(report, "i rms\n");
    else
        APROF_(fprintf)(report, "i drms\n");
    
    // write memory resolution
    APROF_(fprintf)(report, "t %d\n", APROF_(runtime).memory_resolution);
    
    #if EVENTCOUNT
    APROF_(fprintf)(report, "c JSR=%llu - RTS=%llu - RD=%llu - WR=%llu\n", 
            tdata->num_func_enter, tdata->num_func_exit, 
            tdata->num_read + tdata->num_modify,
            tdata->num_write + tdata->num_modify);
    #endif
    
    // write application name
    APROF_(fprintf)(report, "a %s\n", prog_name);
    
    // write commandline
    APROF_(fprintf)(report, "f %s", prog_name);
    XArray * x = VG_(args_for_client);
    int i = 0;
    for (i = 0; i < VG_(sizeXA)(x); i++) {
        HChar ** c = VG_(indexXA)(x, i);
        if (c != NULL) {
            APROF_(fprintf)(report, " %s", *c);
        }
    }
    APROF_(fprintf)(report, "\n");

    // iterate over routines
    HT_ResetIter(tdata->rtn_ht);
    RoutineInfo * rtn_info = HT_RemoveNext(tdata->rtn_ht);
    while (rtn_info != NULL) {
        
        if (!rtn_info->fn->discard) {
        
            const HChar * obj_name = "NONE";
            if (rtn_info->fn->obj != NULL)
                obj_name = rtn_info->fn->obj->name; 
        
            APROF_(fprintf)(report, "r \"%s\" \"%s\" %llu\n", 
                        rtn_info->fn->name, obj_name, 
                        rtn_info->routine_id);
        
            if (rtn_info->fn->mangled != NULL) {
                APROF_(fprintf)(report, "u %llu \"%s\"\n", 
                                rtn_info->routine_id, 
                                rtn_info->fn->mangled);
            }

            // iterate over tuples
            HT_ResetIter(rtn_info->input_map);
            Input * tuple = HT_RemoveNext(rtn_info->input_map);
            while (tuple != NULL) {
            
                if (APROF_(runtime).collect_CCT)
                    APROF_(fprintf)(report, "q %lu ", tuple->context_id);
                else
                    APROF_(fprintf)(report, "p %lu ", rtn_info->routine_id);
                
                APROF_(fprintf)(report,
                                "%lu %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu",
                                tuple->input_size,
                                tuple->min_cumulative_cost,
                                tuple->max_cumulative_cost,
                                tuple->sum_cumulative_cost, 
                                tuple->sqr_cumulative_cost,  
                                tuple->calls,
                                tuple->sum_cumul_real_cost,
                                tuple->sum_self_cost,
                                tuple->min_self_cost,
                                tuple->max_self_cost,
                                tuple->sqr_self_cost
                                );
                
                #if INPUT_STATS
                if (APROF_(runtime).input_metric == DRMS) {
                    
                    APROF_(fprintf)(report,
                                    " 0 0 %llu %llu %llu %llu",
                                    tuple->sum_cumul_syscall,
                                    tuple->sum_cumul_thread,
                                    tuple->sum_self_syscall,
                                    tuple->sum_self_thread
                                    );
                }
                #endif
                
                APROF_(fprintf)(report, "\n");
                APROF_(delete)(INPUT_S, tuple);
                tuple = HT_RemoveNext(rtn_info->input_map);
            }
            
        }
        
        APROF_(destroy_routine_info)(rtn_info);
        rtn_info = HT_RemoveNext(tdata->rtn_ht);
    }
    
    if (APROF_(runtime).collect_CCT)
        APROF_(print_report_CCT)(report, tdata->root, 0);
    
    // close report file
    APROF_(fclose)(report);
    
    VG_(umsg)("Report: %s\n", filename);
    VG_(free)(filename);
    
    #if MEM_USAGE_INFO
    if (APROF_(runtime).running_threads == 1)
        APROF_(print_info_mem_usage)();
    #endif
}
